//1. Які категорії типів даних існують у Java?
//2. Перерахуйте типи даних Java.
//3. Тип даних char, що зберігає, область визначення.
//4. Напишіть метод main (два варіанти).
//5. Вкажіть автоматичні перетворення між примітивними типами
//6. За яких перетворень між примітивними типами можлива втрата інформації?
//7. Які перетворення між типами ви знаєте.
//8. Що таке wrappers, autoboxing, autounboxing.
//9. Напишіть анонімний масив.
//10. Напишіть приклад двомірного масиву.

//- 1. Категорії типів даних у Java:
//
//Примітивні типи даних (Primitive Data Types)
//Складені типи даних (Composite Data Types), такі як масиви
//Посилальні типи даних (Reference Data Types), такі як об'єкти класів, інтерфейси та масиви.

//**Примітивні типи даних (Primitive Data Types):**
//
//        - `byte`:`short`:`int`:`long`:`float`:`double`:`char`:`boolean`:

// **Складені типи даних (Composite Data Types), такі як масиви:**
//
//        - Одновимірний масив:
//        - Двовимірний масив:
//**Посилальні типи даних (Reference Data Types), такі як об'єкти класів, інтерфейси та масиви:**
//
//        - Об'єкт класу:
//        ```java
//class Person {
//    String name;
//    int age;
//
//    Person(String name, int age) {
//        this.name = name;
//        this.age = age;
//    }
//}
//
//Person person = new Person("John", 30);
//     ```
//
//             - Інтерфейс:
//        ```java
//interface Animal {
//    void makeSound();
//}
//
//class Dog implements Animal {
//    public void makeSound() {
//        System.out.println("Woof");
//    }
//}
//
//Animal animal = new Dog();
//     ```
//
//             - Масив (який також є посилальним типом):
//        ```java
//String[] names = {"Alice", "Bob", "Charlie"};
//     ```


//3. Тип даних char, що зберігає, область визначення. Тип даних char:
//
//Зберігає одиничний 16-бітовий символ Unicode.
//Область визначення: від \u0000 (0) до \uffff (65,535).

//4. Напишіть метод main (два варіанти)
//Метод main (два варіанти):
//
//public class Main {
//    public static void main(String[] args) {
//        System.out.println("Hello, world!");
//    }
//}
//public class Main {
//    public static void main(String... args) {
//        System.out.println("Hello, world!");
//    }
//}
//Синтаксична різниця:
//
//String[] args – стандартне оголошення масиву.
//String... args – варіативний аргумент, який дозволяє передавати довільну кількість параметрів.

//5. Вкажіть автоматичні перетворення між примітивними типами
//Автоматичні перетворення між примітивними типами:
//
//Вузький тип до ширшого типу (Widening Conversion):
//byte → short → int → long → float → double
//char → int → long → float → double

//Приклади:
//byte до short:
//byte b = 10;
//short s = b;  // автоматичне перетворення від byte до short

//int до long:
//int i = 100;
//long l = i;  // автоматичне перетворення від int до long

//float до double:
//float f = 10.5f;
//double d = f;  // автоматичне перетворення від float до double

//char до int:
//char c = 'A';
//int i = c;  // автоматичне перетворення від char до int

//6. За яких перетворень між примітивними типами можлива втрата інформації?
//Перетворення між примітивними типами, де можлива втрата інформації:

//З ширшого типу до вузького типу (Narrowing Conversion):
//double → float
//float → long
//long → int
//int → short або char
//short → byte

//Приклад:
          //double → float
//Причина втрати: double має 64 біти для зберігання чисел з плаваючою точкою, тоді як float має лише 32 біти.
//Це може призвести до втрати точності після перетворення.
//double d = 12345.678901234567;
//float f = (float) d;  // Втрата точності
//System.out.println(f);  // Виведе 12345.679

//7. Які перетворення між типами ви знаєте.
//Перетворення між типами:
//
//Примітивні до примітивних (widening, narrowing)
//Примітивні до обгорток (wrappers) та навпаки (autoboxing, unboxing)
//Посилальні до посилальних (upcasting, downcasting)
//Примітивні до стрічок та навпаки (методи valueOf, parseX, toString)

//8. Що таке wrappers, autoboxing, autounboxing.
//Wrappers, autoboxing, autounboxing:
//
//Wrappers: Класи-обгортки для примітивних типів, які дозволяють використовувати їх як об'єкти.
//Наприклад: Integer для int, Double для double.
//Autoboxing: Автоматичне перетворення примітивного типу в об'єкт класу-обгортки.
//Наприклад: int до Integer.
//        Autounboxing: Автоматичне перетворення об'єкта класу-обгортки в примітивний тип.
//Наприклад: Integer до int.


//9. Напишіть анонімний масив.
//Анонімний масив:
//int[] anonymousArray = new int[]{1, 2, 3, 4, 5};

//1. Анонімний масив
//Анонімний масив створюється без присвоєння змінної для зберігання посилання на масив.
// Він використовується прямо при виклику методу або у конструктора.

//public static void main(String[] args) {
//    // Використання анонімного масиву як аргументу методу
//    printArray(new int[]{10, 20, 30, 40, 50});  // Створення анонімного масиву
//}
//В цьому прикладі масив {10, 20, 30, 40, 50} є анонімним, оскільки він створюється і
// використовується одразу як аргумент методу printArray

//2. Не анонімний масив
//Не анонімний масив спочатку створюється як змінна, і лише потім використовується. Це дозволяє зберігати посилання на масив і використовувати його в різних частинах програми.
//public static void main(String[] args) {
//    // Створення не анонімного масиву і присвоєння його змінній
//    int[] myArray = {10, 20, 30, 40, 50};  // Не анонімний масив
//
//    // Використання масиву у методі
//    printArray(myArray);
//
//    // Можливість повторного використання масиву
//    int sum = calculateSum(myArray);
//    System.out.println("Sum: " + sum);
//}
//У цьому прикладі масив myArray є не анонімним, оскільки він спочатку створюється і присвоюється змінній myArray. Цю змінну можна використовувати в різних методах (як-от printArray і calculateSum), і вона може бути модифікована або використана для різних цілей в межах програми.

//10. Напишіть приклад двомірного масиву.
//public static void main(String[] args) {
//    int[][] matrix = {
//            {1, 2, 3},
//            {4, 5, 6},
//            {7, 8, 9}
//    };